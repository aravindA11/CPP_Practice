Common
> In general all the standard libraries are stored in namespace std.
> Type of a variable let us know what type of data can be stored and the operations possible on the variable.
> All the headerfiles must be written in single line.
> Statements in a program are executed sequentually. 

Comments
========
> Two types of Comments:
	single line(//): Everything to the right of the slashed on the current line is ignored by the Compiler
	paired(/**/): two delemeters they ignore a block of statements. The block can be started anywhere and closed anywhere.
> Compiler ignores comments so they have no effect on the program's behavior or performance.
> Comments cannot be nested.
> Comments are not allowed to be written after header files
> 


Built-in Types:
===============
Primitive types: arithematic + void
arithematic: integral types(int, char, bool, long) + floating value types(float, double)
> integral types except bool and widechar types can be signed and unsigned.
> We cannot define variables of unsigned float the same follows for bool.
> 

Variables
> A variable represents a built-int type or a user defined type
> A variable name cannot start with a number. _, alphabets are allowed.
> Numbers can be part of the variable names.
> The default value of a variable is zero in golbal scope and random value if it is defined inside a function.
> there is no character with '' but string works fine with "".

> Variable follows scope where it is defined.
> Everyname used in a c++ program must be declared before using it.
> Care should be take for scope of declarations. These leads to disastrus results which are hard to find.

literals
> The string literal which we use is of type const char[].
> false, true are literals of type bool.



Expressions:
============
> The compiler follows precedence and associativity to execute an expression.
> A class can define its own overloading operator to write its own behavior when the opertor is applied. 
But the precedence number of operands, associativity doesn't change.


Compound Types:
==============
> In order to understand compound types always read from right to left.
> Types which are formed by modifying original types are called compound types.

references
> References are of the for &d.
> They bind to the objects they are initialised. hence they need to be initialised by default.
> They are not individual objects in their own right.
> we can have references to pointers.
	eg: int *&p;
> References doesn't have top level constant.
> Since, references are not objects we can't create pointers to references.


Pointers
> pointers are of the form type *d
> They store address of an object.
> They are individual objects in their own right.
> The type of the pointer and the object must be same (except Inheritence).
> By default pointers are not initialised in block scope.
> We can initlise pointeres to nullptr, 0 by default to avoid undefined behavior.
> Accessing the data of a nullptr pointer or unintialised pointer gives undefined behavior.
> Two pointers can be compared if they are of same type. Error is thrown if they are of different type(exception for void types).
> pointer type is the only type which can represent both top level and low level constant independently.


Arrays
> Array's store objects, references are not objects so we cannot create array of references.
> arrays cannot be copied/moved directly. (Except if the compilers provide such functionality)
> If an array is used to store with auto it is treated as a pointer rather than a group of objects with a specific size.
> Array's use subscript operator defined by the language.
> It can be easier to understand array declarations by starting with the array’s name and reading them from the inside out.
> Using auto on arrays will deduce pointer to the type of array not array of elements.

Q&A

> Can we define array of zero size?
	No, we cannot define array of size zero directly.
	but this program works fine.
	
	struct fun {
	int x;
	char p[0];
	};

> What happens if we give more initializer values to array than it's size?
	Compiler throws error.
	int ar[2] ={1,2,3,4};
> What happens if we compare these two arrays?
int ar1[5] = {1,2,3,4,5};
    int ar2[5] = {1,2,3,4,5};

	if(ar1 > ar2)
		cout<<"ar1 is bigger";
	else
		cout<<"ar2 is bigger";
	here the comparision happens on the pointer value of ar1, ar2 rather than on elements.
> How to deduce array using auto?
	there is no way to do so.

Flow of Control
==============
Statements:
>  The simplest statement is the empty statement, also known as a null statement (;)
> A block is a (possibly empty) sequence of statements and declarations surrounded by a pair of curly braces.
>  A block is not terminated by a semicolon.
> 
> flow-of-control statements that allow for more complicated execution paths.
	While Statement:
		> It repeatedly executes a section so long as a given condition is true.
		Syntex:
			While(condition)
				statement
	For Statement:
		> A for statement has 2 parts:
			A header and a body
		> A header itself consists of 3 parts:
			an init statement, a condition, an expression
		> init statement is executed once and then the loop starts as long as the condition becomes false, the expression executes at the end of each loop.
	Do While Statement:
		> It executes the body and then tests the condition.
		do
			statement
		while (condition);
	If Statement:
		> It allows executing a statement when the condition validates to true.
		Syntex 1:
			if(condition)
				statement
		Suntex 2:
			if(condition)
				statement
			else
				statement2
		> Dangling else: in C++ the ambiguity is resolved by specifying that each else is matched with the closest preceding unmatched if. 
	Switch Statement:
		> The switch statement evaluates an integral expression and chooses one of several execution paths based on the expression’s value.
		>  The case keyword and its associated value together are known as the label. case labels must be integral constant expressions.
		> The execution starts at the matching expression and continues till the end of switch statement or a break statement.
		> Switch is the only statement which allows break.
		>  It is important to understand that execution flows across case labels. After a case label is matched, 
		execution starts at that label and continues across all the remaining cases or until the program explicitly interrupts it.
		> Each case label can have only a single value.
		>  Although it is not necessary to include a break after the last label of a switch, the safest course is to provide one. That way, if an additional
			case is added later, the break is already in place.
		>  The statements following the default label are executed when no case label matches the value of the switch expression.
		>  A label may not stand alone; it must precede a statement or another case label. 

Functions
=========

> A function generally have 4 parts:
	Function Name, Return Type, parameters, Function Body.
> A function body is a block of statements enclosed in a curly braces. This cannot be a single open statement as used by flow of control statements.
> Main is the only function where the return statement can be avoided.
> A parameter that has a top-level const is indistinguishable from one without a top-level const.
> Function overloading doesn't happen if the return type is the only difference, the second declaration is an error.
> We cannot define functions inside functions but declarations of functions possible.
> Function overloading follows scope.
> Functions with default arguments can be called with or without that argument. 
> If a parameter has a default argument, all the parameters that follow it must also have default arguments.
> The default arguments are used for the trailing (right-most) arguments of a call.
> Any subsequent declaration can add a default only for a parameter that has not previously had a default specified
> If there are no viable functions, the compiler will complain that there is no matching function.
> 

Q&A

> Can we call main function in the same file?
	Yes, recursion is possible with main function
> Is overloading of main function possible?
	No, main cannot be overloaded
> Can static members be function parameters?
	No, static members cannot be function parameters
> 



Classes
=======
> Every class defines a type. The type name is the same as the name of the class.
> Eaach and every class have a default constructor, destructor, copy constructor, copy operator, move constructor, move operator defined by the compilers.
> Constructors doesn't have return type.
> The name of a constructor should be same as name of class. It is used to initialise the data members of the object.
> Constructors can be overloaded. Constructors cannot be const they are used to initialise members of the object regardless of constness of object.
> Copy and move constructors are created even after we defined our own constructor.
> Accesses specifiers are applicable to every entitiy(methods, constructors, static variables/methods, using declarations) present in the class except for friends.
> Compiler processes classes in two steps—the member declarations are compiled first, after which the member
 function bodies, if any, are processed.
> By the time the body of constructors starts executing the members are initialised.
> We use this to implicitly call members of the current object. this has a type of constant pointer.
> Friend members can be defined in the class but inordered to be used outside of the class they must be declared in the scope outside of the class.
> The explicit, static keywords are used only on the declaration inside the class. They are not repeated on a definition made outside the
 class body.

Initializer List:
> Initializer list allows providing values to constant objects.
> The list members are initialized based on the order of their declarations in the class not the way they are written in the initilzer list.
> Initializer list values are given preference over in class initialzation values.
> It is mainly used for initialising constants, references, base part of derived classes.
> We can't initialise static members in initialiser list.

Functions inside Classes:
> Functions inside classes are called methods.
> Methods of a class must be declared inside the class. At the same time definitions can be at any place.
> The declarations, definitions must match including const.
> Functions defined in the class are implicitly inline.
> 
> Each and every method of a class can have their own static members, including constructors they are independent of objects.
> Methods can be left declared but not defined as long as they are not used by the object defined by the class.
> Methods and destructor are the only entities that can be override in Inheritence of classes
> Static functions can be called without creating objects.
> this is the default parameter passed to every method of a class. It is not applicable with static functions.

Q&A
> Constructors be constant?
> What are the use cases of initialzer list?
	They are mainly used to initlaize constant variables, references, derived class initilize their base part
> Can we use this in initializer list?
	Yes, using this in initializer list is allowed.
> Can static members be initialised in initializer list?
	No, one should not initialise them in initialiser list
> How cin can be used as a condition for control statements?
	It is done via bool operator ooverloading by the class
> Can we call a method of a class without creating a object?
	Yes, it is possible with class ptr without any members of the object called.

	#include<iostream>
	using namespace std;

	class Sample {
		int a=10;
		public:
		void print(){
			std::cout<<"print function being called"<<std::endl;
			// std::cout<<a; // Error as we are calling on a nullptr 
		}
	};

	int main() {
		Sample *sptr = nullptr;
		sptr->print();
		return 0;
	}
> Can we create and initialise static member of a class within the class?
	yes, we can them for constant members and when the static member is inline
> Can an object access private members of a different object of same class type?
	yes, it is possible when the object is accessed by methods of same class or by friends
> 